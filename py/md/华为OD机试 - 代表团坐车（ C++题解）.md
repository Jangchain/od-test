#### 题目描述:代表团坐车

某组织举行会议，来了多个代表团同时到达，接待处只有一辆汽车，可以同时接待多个代表团，为了提高车辆利用率，请帮接待员计算可以坐满车的接待方案，输出方案数量。

约束:

  1. 一个团只能上一辆车，并且代表团人数 (代表团数量小于30，每个代表团人数小于30)小于汽车容量(汽车容量小于100)
  2. 需要将车辆坐满

#### 输入描述

第一行 代表团人数，英文逗号隔开，代表团数量小于30，每个代表团人数小于30  
第二行 汽车载客量，汽车容量小于100

#### 输出描述

坐满汽车的方案数量  
如果无解输出0

##### ACM输入输出模式

如果你经常使用**Leetcode** ,会知道**letcode** 是不需要编写输入输出函数的。但是华为OD机考使用的是 **ACM 模式**
，需要手动编写输入和输出。

所以最好在牛-
客上提前熟悉这种模式。例如C++使用`cin/cout`,python使用`input()/print()`。JavaScript使用node的`readline()`和`console.log()`。Java
使用`sacnner/system.out.print()`

#### 用例

输入

    
    
    5,4,2,3,2,4,9
    10
    

输出

    
    
    4
    

说明

> 解释 以下几种方式都可以坐满车，所以，优先接待输出为4
>
> [2,3,5]
>
> [2,4,4]
>
> [2,3,5]
>
> [2,4,4]

#### 代码思路

题目要求计算可以坐满车的接待方案，输出方案数量。我们可以采用动态规划的思想来解决这个问题。

首先，我们需要明确状态和状态转移方程。

状态：我们可以用 dp[i] 表示载客量为 i 时的方案数。

状态转移方程：假设当前有一个代表团，人数为 group，我们可以有两种选择：

  * 不接待这个代表团，此时方案数为 dp[i]；
  * 接待这个代表团，此时方案数为 dp[i - group]。

因此，我们可以得到状态转移方程：

dp[i] = dp[i] + dp[i - group]

其中，dp[i] 表示不接待当前代表团时的方案数，dp[i - group] 表示接待当前代表团后的方案数。

接下来，我们需要考虑如何初始化和边界情况。

初始化：当载客量为 0 时，方案数为 1（不接待任何代表团）。

边界情况：当载客量小于当前代表团人数时，无法接待该代表团，方案数不变。

最后，我们需要遍历所有代表团，将状态转移方程应用到每个代表团上，最终得到载客量为汽车载客量时的方案数。

#### 机考代码查重

华为OD机考完成之后，官方会进行代码查重。**华为 od 机考确实有很大的概率抽到原题**
。如果碰到了题库中的原题，一定不要直接使用题解中的代码，尤其是变量名，一定要修改，可以改成毫无意义的单词。除了变量名之外，代码的组织结构和逻辑一定要进行改变，这就要求在日常的刷题中，提前编写好属于自己的代码。

#### C++

    
    
    #include <iostream>
    #include <sstream>
    #include <vector>
    #include <algorithm>
    using namespace std;
    
    int main() {
        string input;
        getline(cin, input);
    
        // 读取代表团人数
        stringstream ss(input);
        vector<int> groups;
        int num;
        char comma;
        while (ss >> num) {
            groups.push_back(num);
            ss >> comma;
        }
    
        // 读取汽车载客量
        int capacity;
        cin >> capacity;
    
        // 初始化动态规划数组，dp[i]表示载客量为i时的方案数
        vector<int> dp(capacity + 1);
        dp[0] = 1; // 载客量为0时，方案数为1（不接待任何代表团）
    
        // 动态规划转移
        for (int group : groups) {
            for (int j = capacity; j >= group; j--) { // 从后往前遍历，避免重复计算
                dp[j] += dp[j - group]; // 转移方程：dp[j] += dp[j - group]，表示加上接待当前代表团后的方案数
            }
        }
    
        // 输出结果
        if (dp[capacity] == 0) { // 无解
            cout << 0 << endl;
        } else { // 有解
            cout << dp[capacity] << endl;
        }
    
        return 0;
    }
    
    

> #### 文章目录
>
>   *     *       * 题目描述:代表团坐车
>       * 输入描述
>       * 输出描述
>       *         * ACM输入输出模式
>       * 用例
>       * 代码思路
>       * 机考代码查重
>       * C++
>

![fengmian](https://img-
blog.csdnimg.cn/img_convert/b98429f56d7b21e9abb6e238d4c69d08.png)

