#### 题目描述

对于任意两个正整数A和B，定义它们之间的**差异值和相似值** ：  
**差异值：**A、B转换成二进制后，对于二进制的每一位，对应位置的bit值不相同则为1，否则为0；  
**相似值：**A、B转换成二进制后，对于二进制的每一位，对应位置的bit值都为1则为1，否则为0；  
现在有n个正整数A0到A（n-1），问有多少(i, j) (0<=i<j<n），Ai和Aj的差异值大于相似值。  
假设A=5，B=3；则A的二进制表示101；B的二进制表示011；  
则A与B的差异值二进制为110；相似值二进制为001；  
A与B的差异值十进制等于6，相似值十进制等于1，满足条件。

#### 输入描述

一个n接下来n个正整数

**数据范围** ：1<=n<=105，1<=A[i]<230

#### 输出描述

满足差异值大于相似值的对数

#### 用例

输入| 4  
4 3 5 2  
---|---  
输出| 4  
说明| 满足条件的分别是(0,1)(0,3)(1,2)(2,3)，共4对。  
  
#### 题目解析

题目描述中，

A，B差异值其实就是A和B二进制的[按位异或](https://so.csdn.net/so/search?q=%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96&spm=1001.2101.3001.7020)运算，即A
^ B。

A，B相似值其实就是A和B二进制的按位与运算，即A & B。

本题主要是找规律：

本题的规律其实很容易发现，那就是看A，B的最高位1是否处于相同位，如果相同，比如

A：1010

B：1100

那么差异值就是0110，相似值就是1000，可以发现，A,B最高位的1，在按位异或运算下被换成0，在按位与的运算下，变成了1，因此这种情况下，相似值必然大于差异值，不符合要求。

如果A，B的最高位1不处于相同位，比如

A：1010

B：0110

那么差异值就是1100，相似值就是0010，可以发现，A，B的最高位不同，因此按位异或运算下被换成了1，而按位与运算下变成了0，因此这种情况下，差异值必然大于相似值，符合要求。

总结：

差异值的最高位为1，相似值的最高位为0。因此我们只要找到最高位的1的种类，然后相互组合即可。

#### C++

    
    
    #include <iostream>
    #include <vector>
    #include <bitset>
    
    using namespace std;
    
    int main() {
        int n;
        cin >> n;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
    
        // 统计每个数二进制下最高位的位置
        vector<int> highBitCount(32, 0);
        for (int i = 0; i < n; i++) {
            int a = arr[i];
            int highBit = 31 - __builtin_clz(a);
            highBitCount[highBit]++;
        }
    
        // 计算差异值大于相似值的对数
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            for (int j = i + 1; j < 32; j++) {
                if ((i ^ j) > (i & j)) {
                    ans += highBitCount[i] * highBitCount[j];
                }
            }
        }
        cout << ans << endl;
        return 0;
    }
    
    

#### 文章目录

  *     *       * 题目描述
      * 输入描述
      * 输出描述
      * 用例
      * 题目解析
      * C++

![fengmian](https://img-
blog.csdnimg.cn/img_convert/1d2f33ed8cf2fb1b9a4fe09513f7aa94.png)

