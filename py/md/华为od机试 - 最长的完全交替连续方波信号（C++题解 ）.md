#### 题目描述:最长的完全交替连续方波信号

> 输入一串方波信号，求取最长的完全连续交替方波信号，并将其输出，如果有相同长度的交替方波信号，输出任一即可，
>
> 方波信号高位用1标识，低位用0标识

> 说明：  
>  1） 一个完整的信号一定以0开始然后以0结尾，即010是一个完整信号，但101，1010，0101不是  
>  2）输入的一串方波信号是由一个或多个完整信号组成  
>  3） 两个相邻信号之间可能有0个或多个低位，如0110010，011000010  
>  4） 同一个信号中可以有连续的高位，如01110101011110001010，前14位是一个具有连续高位的信号  
>  5） 完全连续交替方波是指10交替，如01010是完全连续交替方波，0110不是

#### 输入描述

> 输入信号字符串（长度 >= 3 且 <= 1024）：
>
> 0010101010110000101000010 注：输入总是合法的，不用考虑异常情况

#### 输出描述

> 输出最长的完全连续交替方波信号串：01010
>
> 若不存在完全连续交替方波信号串，输出 -1。

##### ACM输入输出模式

如果你经常使用**Leetcode** ,会知道**letcode** 是不需要编写输入输出函数的。但是华为OD机考使用的是 **ACM 模式**
，需要手动编写输入和输出。

所以最好在牛-
客上提前熟悉这种模式。例如C++使用`cin/cout`,python使用`input()/print()`。JavaScript使用node的`readline()`和`console.log()`。Java
使用`sacnner/system.out.print()`

#### 用例

输入

    
    
    00101010101100001010010
    

输出

    
    
    01010
    

说明

> 输入信号串中有三个信号：
>
> 0 010101010110(第一个信号段)
>
> 00 01010(第二个信号段)
>
> 010(第三个信号段)
>
> 第一个信号虽然有交替的方波信号段，但出现了11部分的连续高位，不算完全连续交替方波，
>
> 在剩下的连续方波信号串中01010最长

#### 机考代码查重

华为OD机考完成之后，官方会进行代码查重。**华为 od 机考确实有很大的概率抽到原题**
。如果碰到了题库中的原题，一定不要直接使用题解中的代码，尤其是变量名，一定要修改，可以改成毫无意义的单词。除了变量名之外，代码的组织结构和逻辑一定要进行改变，这就要求在日常的刷题中，提前编写好属于自己的代码。

#### C++

    
    
    #include <iostream>
    #include <string>
    #include <regex>
    using namespace std;
    
    int main() {
        string signal;
        getline(cin, signal); // 输入信号字符串
    
        regex pattern("^(01)+0$"); // 定义正则表达式匹配完全连续交替方波信号
    
        int maxLength = 0; // 最长完全连续交替方波信号的长度
        string result = "-1"; // 最长完全连续交替方波信号的字符串
    
        string sb; // 用于存储当前处理的信号
        for (int i = 0; i < signal.length(); i++) {
            char c = signal[i];
    
            if (c == '0' && sb.length() > 0 && sb[sb.length() - 1] == '0') { // 当前字符是0，且前一个字符也是0，说明一个完整信号结束
                smatch matcher; // 定义匹配结果
                if (regex_match(sb, matcher, pattern) && sb.length() > maxLength) { // 对当前信号进行匹配，如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度
                    maxLength = sb.length(); // 更新最大长度
                    result = sb; // 更新最大长度对应的字符串
                }
                sb = ""; // 清空当前信号
            }
    
            sb += c; // 将当前字符加入当前信号
        }
    
        smatch matcher; // 对最后一个信号进行匹配
        if (regex_match(sb, matcher, pattern) && sb.length() > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度
            result = sb; // 更新最大长度对应的字符串
        }
    
        cout << result << endl; // 输出最长的完全连续交替方波信号串
    
        return 0;
    }
    

#### 文章目录

  *     *       * 题目描述:最长的完全交替连续方波信号
      * 输入描述
      * 输出描述
      *         * ACM输入输出模式
      * 用例
      * 机考代码查重
      * C++
      * 完整用例
      *         * 用例1
        * 用例2
        * 用例3
        * 用例4
        * 用例5
        * 用例6
        * 用例7
        * 用例8
        * 用例9
        * 用例10

![fengmian](https://img-
blog.csdnimg.cn/img_convert/b98429f56d7b21e9abb6e238d4c69d08.png)

#### 完整用例

##### 用例1

    
    
    00101010101100001010010
    

##### 用例2

    
    
    01101010101011000101000010
    

##### 用例3

    
    
    0010101010101010101000010
    

##### 用例4

    
    
    01010101010101010101010010
    

##### 用例5

    
    
    0010101010101010101000001
    

##### 用例6

    
    
    0110010101010110000101000010
    

##### 用例7

    
    
    001010101011000010100001001010101010110000101000010
    

##### 用例8

    
    
    0110101010101100010100001001010101010110000101000010
    

##### 用例9

    
    
    0010101010101010101000010010101010101010101010101010100010
    

##### 用例10

    
    
    0101010101010101010101001001010101010101010101010101010001
    

